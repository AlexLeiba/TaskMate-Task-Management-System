// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../lib/generated/prisma"//generates Prisma client code/adter running npx prisma generate/ prisma creates a fully Typed database client based on the schema
}

datasource db {
  provider = "postgresql"
}

enum PriorityType {
  low
  medium
  high
  urgent
  none
}

model User {
  id String @id @default(uuid())
  name String
  email String @unique
  avatar String?

  attachments Attachments[]
  comments Comment[]
  activitys Activity[]

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  reportedCards Card[] @relation("Reported")//inverse relation/ wont be included in req , unless using property include
  assignedCards Card[] @relation("Assigned")//inverse relation/ wont be included in req , unless using property include
}

model Board {
id String @id @default(uuid())
title String
cardImageUrl String
bgImageUrl String
orgId String
order Int @default(1)

lists List[]//will end up if using includes query
activity Activity[]
createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
}

enum StatusType {
  todo
  progress
  review
  done
  backlog
}

model List { //fetch list based on board id
id String @id @default(uuid())
boardId String //take boardid from url when creating a list
title String
order Int @default(1)

status StatusType @default(todo)
cards Card[] //when create a card will end up here
board Board @relation(fields: [boardId], references:[id],onDelete: Cascade)
createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
}



model Card {
id String @id @default(uuid())
title String
assignedToEmail String?  //
listId String  //to reference in which list is located
listName String
reporterId String//who has created the card/is mandatory
order Int @default(1)

priority PriorityType @default(none)
details CardDetails?

list List @relation(fields:[listId],references:[id] ,onDelete: Cascade)
reporter User @relation("Reported",fields:[reporterId],references: [id])
assignedTo User? @relation("Assigned", fields:[assignedToEmail],references: [email])

updatedAt DateTime? @updatedAt
createdAt DateTime? @default(now())
}

model CardDetails {
  id String @id @default(uuid())
  cardId String @unique
  description String?
  attachments Attachments[]
  comments Comment[]
  checklist Checklist[]
  activities Activity[]
  dueDate DueDate[]
  

  //adds priorities assigned ids
  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  card Card @relation(fields:[cardId],references: [id] ,onDelete: Cascade)
}



model UploadedFile {
  id String @id @default(uuid())
  name String?
  url String
 type String
 fileId String
 attachmentId String //to relate of which attachment it belongs

 attachment Attachments @relation(fields:[attachmentId],references: [id],onDelete: Cascade)//determine on which card was attached file
   createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
}

// when create an attachment: set cardId / based on that id we will know which card belongs to the attach
model Attachments {
  id String @id @default(uuid())
  cardId String
  files UploadedFile[]//all uploaded files based on attach id

  authorId String

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  card CardDetails @relation(fields:[cardId],references: [id],onDelete: Cascade)//determine on which card was attached file
  author User @relation(fields:[authorId],references: [id])
}

model Comment {
  id String @id @default(uuid())
  comment String
  cardId String //if cardId from CardDetails matches with local cardId then it will end up in the table
  authorId String

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  author User @relation(fields:[authorId],references: [id])
  cardDetails CardDetails @relation(fields:[cardId],references: [id], onDelete: Cascade)
}

enum ActivityType {
  created
  updated
  deleted
}

model Activity {
  id String @id @default(uuid())
  activity String
  authorId String
  type ActivityType

  cardId String?
  boardId String?
  orgId String

  author User @relation(fields:[authorId],references: [id])
  cardDetails CardDetails? @relation(fields:[cardId],references: [id])
  board Board? @relation(fields:[boardId],references: [id])

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
}

// register all activities to see who checked something
model Checklist {
  id String @id @default(uuid())
  title String
  isCompleted Boolean
  cardId String
  order Int @default(1)

  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt

  cardDetails CardDetails @relation(fields:[cardId],references: [id], onDelete: Cascade)
}

model DueDate {
  id String @id @default(uuid())
  date String
  time String //will store date in ISO string, is Timezone-safe, works across browsers,servers,DBs, parse format in localtime on using it
  cardId String
  cardDetails CardDetails @relation(fields:[cardId],references: [id], onDelete: Cascade)
  createdAt DateTime? @default(now())
  updatedAt DateTime? @updatedAt
}